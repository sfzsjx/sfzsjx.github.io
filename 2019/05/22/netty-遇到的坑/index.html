<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="天道酬勤">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    netty 遇到的坑 |
    
    上善若水博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
<main class="content">
  <section class="outer">
  

<article id="post-netty-遇到的坑" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      netty 遇到的坑
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/22/netty-遇到的坑/" class="article-date">
  <time datetime="2019-05-22T03:22:08.000Z" itemprop="datePublished">2019-05-22</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络编程/">网络编程</a>
  </div>

      </div>
    

    
      




    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h2 id="一、-进制转换"><a href="#一、-进制转换" class="headerlink" title="一、 进制转换"></a>一、 进制转换</h2><h3 id="1-十进制转为十六进制"><a href="#1-十进制转为十六进制" class="headerlink" title="1. 十进制转为十六进制"></a>1. 十进制转为十六进制</h3><pre><code>int valueTen = 328;
String strHex = Integer.toHexString(valueTen)

</code></pre><h3 id="2-十六进制转十进制"><a href="#2-十六进制转十进制" class="headerlink" title="2. 十六进制转十进制"></a>2. 十六进制转十进制</h3><pre><code>String strHex = &quot;0214010977&quot;
int valueTen = Integer.pareseInt(strHex,16)

</code></pre><h2 id="二、数据类型转换"><a href="#二、数据类型转换" class="headerlink" title="二、数据类型转换"></a>二、数据类型转换</h2><h3 id="1-String字符串转Int整型"><a href="#1-String字符串转Int整型" class="headerlink" title="1. String字符串转Int整型"></a>1. String字符串转Int整型</h3><pre><code>String str = &quot;2019&quot;;
int i = Integer.pareseInt(str);
int j = Integer.valuesOf(str).intValue();

</code></pre><h3 id="2-Int整型转String字符串类型"><a href="#2-Int整型转String字符串类型" class="headerlink" title="2.Int整型转String字符串类型"></a>2.Int整型转String字符串类型</h3><pre><code>int i = 2019;
String str1 = i+&quot;&quot;;
String str2 = String.valueOf(i);

</code></pre><h3 id="3-String转-byte"><a href="#3-String转-byte" class="headerlink" title="3.String转 byte[]"></a>3.String转 byte[]</h3><pre><code>public static byte[] strToByteArray(String str) {
    if (str == null) {
        return null;
    }
    byte[] byteArray = str.getBytes();
    return byteArray;
}

</code></pre><h3 id="4-byte-转String"><a href="#4-byte-转String" class="headerlink" title="4.byte[]转String"></a>4.byte[]转String</h3><pre><code>public static String byteArrayToStr(byte[] byteArray) {
    if (byteArray == null) {
        return null;
    }
    String str = new String(byteArray);
    return str;
}

</code></pre><h3 id="5-byte-转十六进制String"><a href="#5-byte-转十六进制String" class="headerlink" title="5. byte[]转十六进制String"></a>5. byte[]转十六进制String</h3><pre><code>public static String byteArrayToHexStr(byte[] byteArray) {
    if (byteArray == null){
        return null;
    }
    char[] hexArray = &quot;0123456789ABCDEF&quot;.toCharArray();
    char[] hexChars = new char[byteArray.length * 2];
    for (int j = 0; j &lt; byteArray.length; j++) {
        int v = byteArray[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}

</code></pre><h3 id="6-十六进制String转byte"><a href="#6-十六进制String转byte" class="headerlink" title="6. 十六进制String转byte[]"></a>6. 十六进制String转byte[]</h3><pre><code>public static byte[] hexStrToByteArray(String str)
{
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return new byte[0];
    }
    byte[] byteArray = new byte[str.length() / 2];
    for (int i = 0; i &lt; byteArray.length; i++){
        String subStr = str.substring(2 * i, 2 * i + 2);
        byteArray[i] = ((byte)Integer.parseInt(subStr, 16));
    }
    return byteArray;
}

</code></pre><h2 id="三、字节数组操作"><a href="#三、字节数组操作" class="headerlink" title="三、字节数组操作"></a>三、字节数组操作</h2><h3 id="1-合并数组"><a href="#1-合并数组" class="headerlink" title="1. 合并数组"></a>1. 合并数组</h3><pre><code>        /**
     * 合并byte[]数组 （不改变原数组）
     * @param byte_1
     * @param byte_2
     * @return 合并后的数组
     */
    public byte[] byteMerger(byte[] byte_1, byte[] byte_2){  
        byte[] byte_3 = new byte[byte_1.length+byte_2.length];  
        System.arraycopy(byte_1, 0, byte_3, 0, byte_1.length);  
        System.arraycopy(byte_2, 0, byte_3, byte_1.length, byte_2.length);  
        return byte_3;  
    }

</code></pre><h3 id="2-截取数组"><a href="#2-截取数组" class="headerlink" title="2. 截取数组"></a>2. 截取数组</h3><pre><code>    /**
     * 截取byte数组   不改变原数组
     * @param b 原数组
     * @param off 偏差值（索引）
     * @param length 长度
     * @return 截取后的数组
     */
    public byte[] subByte(byte[] b,int off,int length){
        byte[] b1 = new byte[length];
        System.arraycopy(b, off, b1, 0, length);
        return b1;
    }

</code></pre><h2 id="四、时间字符串转时间戳格式"><a href="#四、时间字符串转时间戳格式" class="headerlink" title="四、时间字符串转时间戳格式"></a>四、时间字符串转时间戳格式</h2><pre><code>public class TimeFormatTest {
    public static void main(String[] args) throws ParseException {
        String time = &quot;2019-5-23 9:24:1&quot;;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

        java.util.Date date_util = sdf.parse(time); //转换为util.date
        java.sql.Date date_sql = new java.sql.Date(date_util.getTime());//转换为sql.date
        System.out.println(date_util);
        System.out.println(date_sql);
        String date = sdf.format(date_sql);
        System.out.println(date);
        date = sdf.format(date_util);
        System.out.println(date);

    }
    }

</code></pre><h2 id="五、-netty和springboot整合"><a href="#五、-netty和springboot整合" class="headerlink" title="五、 netty和springboot整合"></a>五、 netty和springboot整合</h2><p>引入pom.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.gree.cn&lt;/groupId&gt;
    &lt;artifactId&gt;basedata&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;basedata&lt;/name&gt;
    &lt;description&gt;get base data&lt;/description&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- spring boot begin--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- springboot 和 netty 整合 socket--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
            &lt;version&gt;4.1.31.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- spring boot 和 netty整合 socket 结束--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.16.20&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
            &lt;version&gt;5.2.0&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--kafka 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--mysql 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.44&lt;/version&gt;
        &lt;/dependency&gt;


        &lt;!-- log4j--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
            &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;


</code></pre><p>其中主要引入包为：</p>
<pre><code> &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
            &lt;version&gt;4.1.31.Final&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre><h3 id="第一步创建NettyTcoServer服务端"><a href="#第一步创建NettyTcoServer服务端" class="headerlink" title="第一步创建NettyTcoServer服务端"></a>第一步创建NettyTcoServer服务端</h3><pre><code>package com.gree.cn.basedata.server;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.util.concurrent.Future;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.PreDestroy;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class NettyTcpServer {

    private static final Logger log = LoggerFactory.getLogger(NettyTcpServer.class);
    //boss事件轮询线程组
    //处理Accept连接事件的线程，这里线程数设置为1即可，netty处理链接事件默认为单线程，过度设置反而浪费cpu资源
    private EventLoopGroup boss = new NioEventLoopGroup(1);
    //worker事件轮询线程组
    //处理hadnler的工作线程，其实也就是处理IO读写 。线程数据默认为 CPU 核心数乘以2
    private EventLoopGroup worker = new NioEventLoopGroup();

    @Autowired
    ServerChannelInitializer serverChannelInitializer;

    @Value(&quot;${netty.tcp.client.port}&quot;)
    private Integer port;

    //与客户端建立连接后得到的通道对象
    private Channel channel;

    /**
     * 存储client的channel
     * key:ip，value:Channel
     */
    public static Map&lt;String, Channel&gt; map = new ConcurrentHashMap&lt;String, Channel&gt;();

    /**
     * 开启Netty tcp server服务
     *
     * @return
     */
    public ChannelFuture start() {
        //启动类
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        serverBootstrap.group(boss, worker)//组配置，初始化ServerBootstrap的线程组
                .channel(NioServerSocketChannel.class)///构造channel通道工厂//bossGroup的通道，只是负责连接
                .childHandler(serverChannelInitializer)//设置通道处理者ChannelHandler////workerGroup的处理器
                .option(ChannelOption.SO_BACKLOG, 1024)//socket参数，当服务器请求处理程全满时，用于临时存放已完成三次握手请求的队列的最大长度。如果未设置或所设置的值小于1，Java将使用默认值50。
                .childOption(ChannelOption.SO_KEEPALIVE, true);//启用心跳保活机制，tcp，默认2小时发一次心跳
        //Future：异步任务的生命周期，可用来获取任务结果
        ChannelFuture channelFuture1 = serverBootstrap.bind(port).syncUninterruptibly();//绑定端口，开启监听，同步等待
        if (channelFuture1 != null &amp;&amp; channelFuture1.isSuccess()) {
            channel = channelFuture1.channel();//获取通道
            log.info(&quot;Netty tcp server start success, port = {}&quot;, port);
        } else {
            log.error(&quot;Netty tcp server start fail&quot;);
        }
        return channelFuture1;
    }

    /**
     * 停止Netty tcp server服务
     */
    @PreDestroy
    public void destroy() {
        if (channel != null) {
            channel.close();
        }
        try {
            Future&lt;?&gt; future = worker.shutdownGracefully().await();
            if (!future.isSuccess()) {
                log.error(&quot;netty tcp workerGroup shutdown fail, {}&quot;, future.cause());
            }
            Future&lt;?&gt; future1 = boss.shutdownGracefully().await();
            if (!future1.isSuccess()) {
                log.error(&quot;netty tcp bossGroup shutdown fail, {}&quot;, future1.cause());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(&quot;Netty tcp server shutdown success&quot;);
    }

}

</code></pre><h3 id="第二步编写通道初始化流程"><a href="#第二步编写通道初始化流程" class="headerlink" title="第二步编写通道初始化流程"></a>第二步编写通道初始化流程</h3><pre><code>package com.gree.cn.basedata.server;

import com.gree.cn.basedata.utils.decodeutil.MyDecoder;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
import io.netty.handler.timeout.IdleStateHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;


@Component
public class ServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; {

    @Autowired
    ServerChannelHandler serverChannelHandler;

    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception {
        ChannelPipeline pipeline = socketChannel.pipeline();
        //IdleStateHandler心跳机制,如果超时触发Handle中userEventTrigger()方法
        pipeline.addLast(&quot;idleStateHandler&quot;,
                new IdleStateHandler(10, 0, 0, TimeUnit.MINUTES));
        //自定义编码器
        byte[] delimiterByte = new byte[2];
        delimiterByte[0] = 0x02;
        delimiterByte[1] = 0x14;
        ByteBuf delimiterCode = Unpooled.copiedBuffer(delimiterByte);
        pipeline.addLast(new DelimiterBasedFrameDecoder(64,delimiterCode));
        pipeline.addLast(&quot;decoder&quot;,new MyDecoder());


        //字符串编解码器
      pipeline.addLast(
               new StringDecoder(),
               new StringEncoder());
        //自定义Handler
        pipeline.addLast(&quot;serverChannelHandler&quot;, serverChannelHandler);
    }
}

</code></pre><h3 id="第三步自定义处理数据，并存入kafka"><a href="#第三步自定义处理数据，并存入kafka" class="headerlink" title="第三步自定义处理数据，并存入kafka"></a>第三步自定义处理数据，并存入kafka</h3><pre><code>package com.gree.cn.basedata.server;

import com.gree.cn.basedata.kafka_netty.KafkaProducerSingleton;
import com.gree.cn.basedata.utils.DateUtils;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.timeout.IdleState;
import io.netty.handler.timeout.IdleStateEvent;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.InputStream;
import java.util.Properties;

@Component
@ChannelHandler.Sharable
@Slf4j
public class ServerChannelHandler extends SimpleChannelInboundHandler&lt;Object&gt; {
    /**
     * @param ctx 通道
     * @param msg 消息
     * @throws Exception 异常消息
     */
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {

        //kafka 生产者配置
        Properties properties = new Properties();
        //加载配置文件
        InputStream is = ServerChannelHandler.class.getResourceAsStream(&quot;/producer.properties&quot;);
        properties.load(is);
        String substring = msg.toString().substring(8, 10);

        // 返回时间戳
        if (substring.equals(&quot;77&quot;)) {
            short yeardate = Short.parseShort(DateUtils.getTimeNow().substring(0, 4));
            int monthdate = Integer.parseInt(DateUtils.getTimeNow().substring(4, 6));
            int daydate = Integer.parseInt(DateUtils.getTimeNow().substring(6, 8));
            int hoursdate = Integer.parseInt(DateUtils.getTimeNow().substring(8, 10));
            int mindate = Integer.parseInt(DateUtils.getTimeNow().substring(10, 12));
            int seconddate = Integer.parseInt(DateUtils.getTimeNow().substring(12, 14));

            byte[] test = new byte[13];
            test[0] = 0x02;
            test[1] = 0x14;
            test[2] = 0x01;
            test[3] = 0x09;
            test[4] = 0x77;
            test[5] = (byte) (0x00FF &amp; yeardate);
            test[6] = (byte) (0x00FF &amp; (yeardate &gt;&gt; 8));
            test[7] = ((byte) monthdate);
            test[8] = ((byte) daydate);
            test[9] = ((byte) hoursdate);
            test[10] = ((byte) mindate);
            test[11] = ((byte) seconddate);

            //生成异或校验码
            byte temp = test[3];
            for (int i = 4; i &lt; test.length; i++) {
                temp ^= test[i];
            }
            test[12] = temp;
            ByteBuf out = Unpooled.buffer();
           // ByteOrder order;
           // order = ByteOrder.LITTLE_ENDIAN;
            //out.order(order);
            out.writeBytes(test);
            ctx.channel().writeAndFlush(out);
        }
        //然后将传入的数据全部写入到kafka内，并加上接收时间
       // VoteProduceSendmsg voteProduceSendmsg = new VoteProduceSendmsg();
        // voteProduceSendmsg.sendMsg(msg+DateUtils.getFormatTimeNow(),properties);
 //      ExecutorService executorService = Executors.newFixedThreadPool(2);
//        executorService.submit(new HandlerProducer(msg));
        KafkaProducerSingleton kafkaProducerSingleton = KafkaProducerSingleton
                .getInstance();
        kafkaProducerSingleton.init(&quot;topic0619&quot;);
        kafkaProducerSingleton.sendKafkaMessage(msg+DateUtils.getFormatTimeNow());
        //kafkaProducerSingleton.close();
        ctx.channel().flush();

    }

    /**
     * 活跃的、有效的通道
     * 第一次连接成功后进入的方法
     *
     * @param ctx 有效的通道
     * @throws Exception 异常
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        super.channelActive(ctx);
        log.info(&quot;tcp client &quot; + getRemoteAddress(ctx) + &quot; connect success&quot;);
        //往channel map中添加channel信息
        NettyTcpServer.map.put(getIPString(ctx), ctx.channel());

    }

    /**
     * 不活动的通道
     * 连接丢失后执行的方法（client端可据此实现断线重连）
     *
     * @param ctx 不活动的通道
     * @throws Exception 异常
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        //删除Channel Map中的失效Client
        log.info(&quot;不活动通道关闭!&quot;);
        NettyTcpServer.map.remove(getIPString(ctx));
        ctx.close();

    }

    /**
     * 异常处理
     * @param ctx 通道
     * @throws Exception 异常
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        super.exceptionCaught(ctx, cause);
        //发生异常，关闭连接
        log.error(&quot;引擎 {} 的通道发生异常，即将断开连接&quot;, getRemoteAddress(ctx));
        ctx.close();//再次建议close
    }

    /**
     * 心跳机制，超时处理
     * @param ctx 通道
     * @param evt 事件
     * @throws Exception 异常
     */
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        String socketString = ctx.channel().remoteAddress().toString();
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            if (event.state() == IdleState.READER_IDLE) {
                log.info(&quot;Client: &quot; + socketString + &quot; READER_IDLE 读超时&quot;);
                ctx.disconnect();//断开
            } else if (event.state() == IdleState.WRITER_IDLE) {
                log.info(&quot;Client: &quot; + socketString + &quot; WRITER_IDLE 写超时&quot;);
                ctx.disconnect();

            } else if (event.state() == IdleState.ALL_IDLE) {
                log.info(&quot;Client: &quot; + socketString + &quot; ALL_IDLE 总超时&quot;);
                ctx.disconnect();
            }
        }
    }

    /**
     * 获取client对象：ip+port
     *
     * @param ctx 通道
     * @return 返回值
     */
    private String getRemoteAddress(ChannelHandlerContext ctx) {
        String socketString = &quot;&quot;;
        socketString = ctx.channel().remoteAddress().toString();
        return socketString;
    }

    /**
     * 获取client的ip
     * @param ctx 通道
     * @return 返回值
     */
    private String getIPString(ChannelHandlerContext ctx) {
        String ipString = &quot;&quot;;
        String socketString = ctx.channel().remoteAddress().toString();
        int colonAt = socketString.indexOf(&quot;:&quot;);
        ipString = socketString.substring(1, colonAt);
        return ipString;
    }

}

</code></pre><pre><code>创建necat 
.\nc.exe -l  -p 9000

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/22/netty-遇到的坑/" data-id="ck3o5xx7f002f8wujvykjgcap"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/netty/">netty</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/05/23/蓝牙信标定位/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            蓝牙信标定位
          
        </div>
      </a>
    
    
      <a href="/2019/05/16/MySQL-语句记录/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">MySQL 语句记录</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 上善若水博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="上善若水博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>