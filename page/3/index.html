<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="天道酬勤">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    上善若水博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">上善若水博客</a></h1>
      <p>大数据</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="上善若水博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        

<article id="post-校验工具类" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/15/校验工具类/">校验工具类</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/06/15/校验工具类/" class="article-date">
  <time datetime="2019-06-15T01:33:40.000Z" itemprop="datePublished">2019-06-15</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/校验/">校验</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>1、异或校验</p>
<pre><code>     ByteBuf out = Unpooled.buffer();   
     byte[] b = new byte[out.readableBytes()];
     // 进行异或校验
     byte temp=b[3];
        for (int i = 4; i &lt;b.length-1; i++) {
            temp ^=b[i];
        }

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/校验工具类/" data-id="ck3o5xx8u004g8wujeixkcqvk"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/校验/">校验</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-jar-包相关知识" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/14/jar-包相关知识/">jar 包相关知识</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/06/14/jar-包相关知识/" class="article-date">
  <time datetime="2019-06-14T06:43:48.000Z" itemprop="datePublished">2019-06-14</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java，jar/">Java，jar</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>1、查看jar包</p>
<pre><code>ps -aux | grep java

</code></pre><p>2、jar 包后台运行</p>
<pre><code>nohup java -jar xxx.jar &gt; xxx.log &amp;

nohup java -jar analysisbasedata-0.0.1-SNAPSHOT.jar &gt; analysisbasedata-0.0.1-SNAPSHOT.log


nohup java -jar /home/lyxbdw/basedata/comsumer/analysisbasedata-0.0.1-SNAPSHOT.jar &gt; /home/lyxbdw/basedata/comsumer/analysisbasedata.log &amp;

nohup java -jar /home/lyxbdw/basedata/server/basedata-0.0.1-SNAPSHOT.jar &gt; /home/lyxbdw/basedata/server/basedata.log &amp;

</code></pre><p>3、杀死进程</p>
<pre><code>kill -9 pid

</code></pre><p>4、查找文件内容</p>
<pre><code>grep &quot;17:46:49&quot; nohup.out

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/14/jar-包相关知识/" data-id="ck3o5xx6r001g8wujw7l95y44"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jar/">jar</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-时间工具类" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/14/时间工具类/">时间工具类</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/06/14/时间工具类/" class="article-date">
  <time datetime="2019-06-14T03:32:37.000Z" itemprop="datePublished">2019-06-14</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/工具类，Java/">工具类，Java</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>::: hljs-center</p>
<p>时间工具类</p>
<p>:::</p>
<pre><code>package com.gree.cn.basedata.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/**
 * 日期时间工具类
 * @author Administrator
 *
 */
public class DateUtils {

    public static final SimpleDateFormat TIME_FORMAT =
            new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    public static final SimpleDateFormat DATE_FORMAT =
            new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    public static final SimpleDateFormat DATEKEY_FORMAT =
            new SimpleDateFormat(&quot;yyyyMMdd&quot;);
    public static final SimpleDateFormat DATE_NOW =
            new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);


    /**
     * 获取某个时刻的时间信息
     *
     */
    public static String getTimeNow(){

        return DATE_NOW.format(new Date());
    }
    /**
     * 获取格式化某个时间
     */
    public  static String getFormatTimeNow(){
        return TIME_FORMAT.format(new Date());
    }

    /**
     * 判断一个时间是否在另一个时间之前
     * @param time1 第一个时间
     * @param time2 第二个时间
     * @return 判断结果
     */
    public static boolean before(String time1, String time2) {
        try {
            Date dateTime1 = TIME_FORMAT.parse(time1);
            Date dateTime2 = TIME_FORMAT.parse(time2);

            if(dateTime1.before(dateTime2)) {
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 判断一个时间是否在另一个时间之后
     * @param time1 第一个时间
     * @param time2 第二个时间
     * @return 判断结果
     */
    public static boolean after(String time1, String time2) {
        try {
            Date dateTime1 = TIME_FORMAT.parse(time1);
            Date dateTime2 = TIME_FORMAT.parse(time2);

            if(dateTime1.after(dateTime2)) {
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 计算时间差值（单位为秒）
     * @param time1 时间1
     * @param time2 时间2
     * @return 差值
     */
    public static int minus(String time1, String time2) {
        try {
            Date datetime1 = TIME_FORMAT.parse(time1);
            Date datetime2 = TIME_FORMAT.parse(time2);

            long millisecond = datetime1.getTime() - datetime2.getTime();

            return Integer.valueOf(String.valueOf(millisecond / 1000));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return 0;
    }

    /**
     * 获取年月日和小时
     * @param datetime 时间（yyyy-MM-dd HH:mm:ss）
     * @return 结果（yyyy-MM-dd_HH）
     */
    public static String getDateHour(String datetime) {
        String date = datetime.split(&quot; &quot;)[0];
        String hourMinuteSecond = datetime.split(&quot; &quot;)[1];
        String hour = hourMinuteSecond.split(&quot;:&quot;)[0];
        return date + &quot;_&quot; + hour;
    }

    /**
     * 获取当天日期（yyyy-MM-dd）
     * @return 当天日期
     */
    public static String getTodayDate() {
        return DATE_FORMAT.format(new Date());
    }

    /**
     * 获取昨天的日期（yyyy-MM-dd）
     * @return 昨天的日期
     */
    public static String getYesterdayDate() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DAY_OF_YEAR, -1);

        Date date = cal.getTime();

        return DATE_FORMAT.format(date);
    }

    /**
     * 格式化日期（yyyy-MM-dd）
     * @param date Date对象
     * @return 格式化后的日期
     */
    public static String formatDate(Date date) {
        return DATE_FORMAT.format(date);
    }

    /**
     * 格式化时间（yyyy-MM-dd HH:mm:ss）
     * @param date Date对象
     * @return 格式化后的时间
     */
    public static String formatTime(Date date) {
        return TIME_FORMAT.format(date);
    }

    /**
     * 解析时间字符串
     * @param time 时间字符串
     * @return Date
     */
    public static Date parseTime(String time) {
        try {
            return TIME_FORMAT.parse(time);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 格式化日期key
     * @param date
     * @return
     */
    public static String formatDateKey(Date date) {
        return DATEKEY_FORMAT.format(date);
    }

    /**
     * 格式化日期key
     * @param datekey
     * @return
     */
    public static Date parseDateKey(String datekey) {
        try {
            return DATEKEY_FORMAT.parse(datekey);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 格式化时间，保留到分钟级别
     * yyyyMMddHHmm
     * @param date
     * @return
     */
    public static String formatTimeMinute(Date date) {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHHmm&quot;);
        return sdf.format(date);
    }

}


</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/14/时间工具类/" data-id="ck3o5xx8r004c8wujxpo85oje"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具类，时间工具类/">工具类，时间工具类</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-scala-正则匹配" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/30/scala-正则匹配/">scala 正则匹配</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/30/scala-正则匹配/" class="article-date">
  <time datetime="2019-05-30T01:54:57.000Z" itemprop="datePublished">2019-05-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a> / <a class="article-category-link" href="/categories/scala/正则匹配/">正则匹配</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>::: hljs-center</p>
<p>scala正则匹配</p>
<p>:::</p>
<ul>
<li>中文字符匹配<br><code>`</code><br>//匹配中文字符,正则表达式<br>val  regrex =”[\u4e00-\u9fa5]”.r<br>//匹配字符串中第一个中文字符<br>val matches = regrex.findFirstMatchIn(dsca_part1).mkString(“”)</li>
</ul>
<pre><code>- 常规括号加数字匹配
</code></pre><p>def get_dsca2(dsac_part2:String): String ={<br>      var dsca_use = dsac_part2<br>          //匹配左括号加5个数字，其中括号需要转义<br>      val partment = “\([0-9]{5}”.r<br>          //匹配多个括号，？代表多次匹配<br>      val partment3 = “\((.*?)\)”.r<br>      val result = partment3.findAllMatchIn(dsca_use)<br>      result.foreach(x =&gt;{<br>      if (partment.findAllMatchIn(x.toString()).isEmpty){<br>      dsca_use =  dsca_use.split(“\(“ +x.toString()+”\)”)(0)<br>      }<br>      })<br>      return dsca_use<br>      }</p>
<p><code>`</code></p>
<h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><p>Scala 的正则表达式继承了 Java 的语法规则，Java 则大部分使用了 Perl 语言的规则。</p>
<p>下表我们给出了常用的一些正则表达式规则：</p>
<p>表达式    匹配规则<br>^    匹配输入字符串开始的位置。<br>$    匹配输入字符串结尾的位置。<br>.    匹配除”\r\n”之外的任何单个字符。<br>[…]    字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。<br>[^…]    反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。<br>\A    匹配输入字符串开始的位置（无多行支持）<br>\z    字符串结尾(类似$，但不受处理多行选项的影响)<br>\Z    字符串结尾或行尾(不受处理多行选项的影响)<br>re<em>    重复零次或更多次<br>re+    重复一次或更多次<br>re?    重复零次或一次<br>re{ n}    重复n次<br>re{ n,}<br>re{ n, m}    重复n到m次<br>a|b    匹配 a 或者 b<br>(re)    匹配 re,并捕获文本到自动命名的组里<br>(?: re)    匹配 re,不捕获匹配的文本，也不给此分组分配组号<br>(?&gt; re)    贪婪子表达式<br>\w    匹配字母或数字或下划线或汉字<br>\W    匹配任意不是字母，数字，下划线，汉字的字符<br>\s    匹配任意的空白符,相等于 [\t\n\r\f]<br>\S    匹配任意不是空白符的字符<br>\d    匹配数字，类似 [0-9]<br>\D    匹配任意非数字的字符<br>\G    当前搜索的开头<br>\n    换行符<br>\b    通常是单词分界位置，但如果在字符类里使用代表退格<br>\B    匹配不是单词开头或结束的位置<br>\t    制表符<br>\Q    开始引号：\Q(a+b)</em>3\E 可匹配文本 “(a+b)<em>3”。<br>\E    结束引号：\Q(a+b)</em>3\E 可匹配文本 “(a+b)*3”。</p>
<h3 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h3><p>实例    描述<br>.    匹配除”\r\n”之外的任何单个字符。<br>[Rr]uby    匹配 “Ruby” 或 “ruby”<br>rub[ye]    匹配 “ruby” 或 “rube”<br>[aeiou]    匹配小写字母 ：aeiou<br>[0-9]    匹配任何数字，类似 [0123456789]<br>[a-z]    匹配任何 ASCII 小写字母<br>[A-Z]    匹配任何 ASCII 大写字母<br>[a-zA-Z0-9]    匹配数字，大小写字母<br>[^aeiou]    匹配除了 aeiou 其他字符<br>[^0-9]    匹配除了数字的其他字符<br>\d    匹配数字，类似: [0-9]<br>\D    匹配非数字，类似: [^0-9]<br>\s    匹配空格，类似: [ \t\r\n\f]<br>\S    匹配非空格，类似: [^ \t\r\n\f]<br>\w    匹配字母，数字，下划线，类似: [A-Za-z0-9_]<br>\W    匹配非字母，数字，下划线，类似: [^A-Za-z0-9_]<br>ruby?    匹配 “rub” 或 “ruby”: y 是可选的<br>ruby*    匹配 “rub” 加上 0 个或多个的 y。<br>ruby+    匹配 “rub” 加上 1 个或多个的 y。<br>\d{3}    刚好匹配 3 个数字。<br>\d{3,}    匹配 3 个或多个数字。<br>\d{3,5}    匹配 3 个、4 个或 5 个数字。<br>\D\d+    无分组： + 重复 \d<br>(\D\d)+/    分组： + 重复 \D\d 对<br>([Rr]uby(, )?)+    匹配 “Ruby”、”Ruby, ruby, ruby”，等等<br>注意上表中的每个字符使用了两个反斜线。这是因为在 Java 和 Scala 中字符串中的反斜线是转义字符。所以如果你要输出 ..，你需要在字符串中写成 .\. 来获取一个反斜线</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/30/scala-正则匹配/" data-id="ck3o5xx7p002l8wujcsk9ahl8"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/正则匹配/">正则匹配</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-Linux-常用命令" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/27/Linux-常用命令/">Linux 常用命令</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/27/Linux-常用命令/" class="article-date">
  <time datetime="2019-05-27T01:43:36.000Z" itemprop="datePublished">2019-05-27</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h3 id="linux系统中清空文件内容的三种方法"><a href="#linux系统中清空文件内容的三种方法" class="headerlink" title="linux系统中清空文件内容的三种方法"></a>linux系统中清空文件内容的三种方法</h3><p>1.使用vi/vim命令打开文件后，输入”%d”清空，后保存即可。但当文件内容较大时，处理较慢，命令如下：</p>
<blockquote>
<p>vim file_name<br>:%d<br>:wq</p>
</blockquote>
<p>2.使用cat命令情况，命令如下：</p>
<blockquote>
<p>cat /dev/null &gt; file_name</p>
</blockquote>
<p>3.使用echo命令清空，此时会在文件中写入一个空行“\n”，命令如下：</p>
<blockquote>
<p>echo “”&gt;file_name</p>
</blockquote>
<p>推荐使用cat命令</p>
<h3 id="vim-跳转最后一行和跳到行首"><a href="#vim-跳转最后一行和跳到行首" class="headerlink" title="vim 跳转最后一行和跳到行首"></a>vim 跳转最后一行和跳到行首</h3><p>第一种方式：</p>
<blockquote>
<p>:$ 跳到最后一行<br>:1 跳到第一行</p>
</blockquote>
<p>第二种方式：</p>
<blockquote>
<p>shift+g 跳到最后一行<br>gg 跳转到第一行</p>
</blockquote>
<p>查找文件关键字内容</p>
<blockquote>
<p>grep -r “test”  /data/reports</p>
</blockquote>
<p>搜索命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>向前搜索指定字符串；搜索时忽略大小写 :set ic</td>
</tr>
<tr>
<td>n</td>
<td>搜索指定字符串的下一个出现位置</td>
</tr>
<tr>
<td>:%s/old/new/g</td>
<td>全文替换指定字符串</td>
</tr>
<tr>
<td>:n1,n2s/old/new/g</td>
<td>在一定范围内替换指定字符串</td>
</tr>
</tbody>
</table>
<p>端口占用查询：</p>
<pre><code>netstat -anlp | grep 80

lsof -i:80

</code></pre><p>查看内存使用情况</p>
<pre><code>free -h

</code></pre><p>查看磁盘使用情况</p>
<pre><code>df -h


</code></pre><p>查看文件创建数量</p>
<pre><code>df -i

</code></pre><p>删除某个文件的小文件</p>
<pre><code>find . -type f -delete
find . -type d -print -delete

</code></pre><p>查看占用线程最大的程序</p>
<pre><code>ps -eLf | wc -l

</code></pre><p>修改服务最大线程数</p>
<pre><code>echo 1000000 &gt; /proc/sys/kernel/pid_max：修改pid_max值为1000000
echo &quot;kernel.pid_max=1000000 &quot; &gt;&gt; /etc/sysctl.confsysctl -p：设置永久生效
</code></pre><p>监控java线程</p>
<pre><code>ps -eLf | grep java | wc -l

</code></pre><p>监控网络客户连接数：</p>
<pre><code>netstat -n | grep tcp | grep 侦听端口 | wc -l
</code></pre><p>linux 将本地文件传给其他服务器</p>
<pre><code>scp -r -P 2122  /home/lyxbdw/basedata/spark-2.4.3-bin-hadoop2.7.tgz  root@lyxbdw-01:/usr/local/spark

注意第二个路径与冒号之间不能有空格

</code></pre><p>查看某个目录下大文件</p>
<pre><code>find / -size +50M | xargs du -h

</code></pre><h2 id="查看CPU情况："><a href="#查看CPU情况：" class="headerlink" title="查看CPU情况："></a>查看CPU情况：</h2><pre><code>cat /proc/cpuinfo |grep &quot;model name&quot; &amp;&amp; cat /proc/cpuinfo |grep &quot;physical id&quot;

</code></pre><h2 id="查看内存大小"><a href="#查看内存大小" class="headerlink" title="查看内存大小"></a>查看内存大小</h2><pre><code>cat /proc/meminfo | grep MemTotal

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/27/Linux-常用命令/" data-id="ck3o5xx67000l8wuj71x3h8d7"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-蓝牙信标定位" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/23/蓝牙信标定位/">蓝牙信标定位</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/23/蓝牙信标定位/" class="article-date">
  <time datetime="2019-05-23T01:55:37.000Z" itemprop="datePublished">2019-05-23</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/蓝牙定位/">蓝牙定位</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>::: hljs-center</p>
<h1 id="蓝牙信标定位"><a href="#蓝牙信标定位" class="headerlink" title="蓝牙信标定位"></a>蓝牙信标定位</h1><p>:::</p>
<h2 id="一、蓝牙信标信号强度转换"><a href="#一、蓝牙信标信号强度转换" class="headerlink" title="一、蓝牙信标信号强度转换"></a>一、蓝牙信标信号强度转换</h2><blockquote>
<p>计算公式： d = 10^((abs(RSSI) - A) / (10 * n))<br>其中：<br>d - 计算所得距离<br>RSSI - 接收信号强度（负值）<br>A - 发射端和接收端相隔1米时的信号强度<br> n - 环境衰减因子</p>
</blockquote>
<p>代码实现：</p>
<pre><code>//信号强度转距离
Integer signal_power = (Integer.valueOf(values.substring(34, 36), 16).shortValue()) -256 ;
Double mesure_distinct = Math.pow(10, (Math.abs(signal_power) - 59) / (10 * 2.0));
</code></pre><p>二 、base数据执行程序</p>
<p>1.基站数据分析</p>
<blockquote>
<p>cd /home/lyxbdw/basedata/comsumer/target/<br>java -jar analysisbasedata-1.0-SNAPSHOT.jar<br>//后台运行程序<br>nohup java -jar analysisbasedata-1.0-SNAPSHOT.jar &amp;</p>
</blockquote>
<p>2.基站数据接收</p>
<blockquote>
<p>cd /home/lyxbdw/basedata/server/target/<br>java -jar basedata-1.0-SNAPSHOT.jar<br>//后台运行<br>nohup java -jar basedata-1.0-SNAPSHOT.jar &amp;</p>
</blockquote>
<h3 id="基站分析数据"><a href="#基站分析数据" class="headerlink" title="基站分析数据"></a><strong>基站分析数据</strong></h3><blockquote>
<p>nohup java -jar /home/lyxbdw/basedata/comsumer/analysisbasedata-0.0.1-SNAPSHOT.jar &gt; /home/lyxbdw/basedata/comsumer/analysisbasedata.log &amp;</p>
</blockquote>
<h3 id="基站接收数据"><a href="#基站接收数据" class="headerlink" title="基站接收数据"></a><strong>基站接收数据</strong></h3><blockquote>
<p>nohup java -jar /home/lyxbdw/basedata/server/basedata-0.0.1-SNAPSHOT.jar &gt; /home/lyxbdw/basedata/server/basedata.log &amp;</p>
</blockquote>
<p>3.Linux jar 包后台运行</p>
<pre><code>#!/bin/bash
nohup java -jar rocketmq-console-ng-1.0.0.jar --server.port=12581 --rocketmq.config.namesrvAddr=127.0.0.1:9876 &gt; log.out &amp;
</code></pre><blockquote>
<p>解释：<br>1、目的是使rocketmq-console-ng-1.0.0.jar在后台运行；<br>2、nohup 就是linux后台挂起的命令<br>3、“&gt; log.out” 指定日志输出位置为log.out</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/23/蓝牙信标定位/" data-id="ck3o5xxao007p8wuj5roejtwl"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蓝牙定位/">蓝牙定位</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-netty-遇到的坑" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/22/netty-遇到的坑/">netty 遇到的坑</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/22/netty-遇到的坑/" class="article-date">
  <time datetime="2019-05-22T03:22:08.000Z" itemprop="datePublished">2019-05-22</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络编程/">网络编程</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h2 id="一、-进制转换"><a href="#一、-进制转换" class="headerlink" title="一、 进制转换"></a>一、 进制转换</h2><h3 id="1-十进制转为十六进制"><a href="#1-十进制转为十六进制" class="headerlink" title="1. 十进制转为十六进制"></a>1. 十进制转为十六进制</h3><pre><code>int valueTen = 328;
String strHex = Integer.toHexString(valueTen)

</code></pre><h3 id="2-十六进制转十进制"><a href="#2-十六进制转十进制" class="headerlink" title="2. 十六进制转十进制"></a>2. 十六进制转十进制</h3><pre><code>String strHex = &quot;0214010977&quot;
int valueTen = Integer.pareseInt(strHex,16)

</code></pre><h2 id="二、数据类型转换"><a href="#二、数据类型转换" class="headerlink" title="二、数据类型转换"></a>二、数据类型转换</h2><h3 id="1-String字符串转Int整型"><a href="#1-String字符串转Int整型" class="headerlink" title="1. String字符串转Int整型"></a>1. String字符串转Int整型</h3><pre><code>String str = &quot;2019&quot;;
int i = Integer.pareseInt(str);
int j = Integer.valuesOf(str).intValue();

</code></pre><h3 id="2-Int整型转String字符串类型"><a href="#2-Int整型转String字符串类型" class="headerlink" title="2.Int整型转String字符串类型"></a>2.Int整型转String字符串类型</h3><pre><code>int i = 2019;
String str1 = i+&quot;&quot;;
String str2 = String.valueOf(i);

</code></pre><h3 id="3-String转-byte"><a href="#3-String转-byte" class="headerlink" title="3.String转 byte[]"></a>3.String转 byte[]</h3><pre><code>public static byte[] strToByteArray(String str) {
    if (str == null) {
        return null;
    }
    byte[] byteArray = str.getBytes();
    return byteArray;
}

</code></pre><h3 id="4-byte-转String"><a href="#4-byte-转String" class="headerlink" title="4.byte[]转String"></a>4.byte[]转String</h3><pre><code>public static String byteArrayToStr(byte[] byteArray) {
    if (byteArray == null) {
        return null;
    }
    String str = new String(byteArray);
    return str;
}

</code></pre><h3 id="5-byte-转十六进制String"><a href="#5-byte-转十六进制String" class="headerlink" title="5. byte[]转十六进制String"></a>5. byte[]转十六进制String</h3><pre><code>public static String byteArrayToHexStr(byte[] byteArray) {
    if (byteArray == null){
        return null;
    }
    char[] hexArray = &quot;0123456789ABCDEF&quot;.toCharArray();
    char[] hexChars = new char[byteArray.length * 2];
    for (int j = 0; j &lt; byteArray.length; j++) {
        int v = byteArray[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}

</code></pre><h3 id="6-十六进制String转byte"><a href="#6-十六进制String转byte" class="headerlink" title="6. 十六进制String转byte[]"></a>6. 十六进制String转byte[]</h3><pre><code>public static byte[] hexStrToByteArray(String str)
{
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return new byte[0];
    }
    byte[] byteArray = new byte[str.length() / 2];
    for (int i = 0; i &lt; byteArray.length; i++){
        String subStr = str.substring(2 * i, 2 * i + 2);
        byteArray[i] = ((byte)Integer.parseInt(subStr, 16));
    }
    return byteArray;
}

</code></pre><h2 id="三、字节数组操作"><a href="#三、字节数组操作" class="headerlink" title="三、字节数组操作"></a>三、字节数组操作</h2><h3 id="1-合并数组"><a href="#1-合并数组" class="headerlink" title="1. 合并数组"></a>1. 合并数组</h3><pre><code>        /**
     * 合并byte[]数组 （不改变原数组）
     * @param byte_1
     * @param byte_2
     * @return 合并后的数组
     */
    public byte[] byteMerger(byte[] byte_1, byte[] byte_2){  
        byte[] byte_3 = new byte[byte_1.length+byte_2.length];  
        System.arraycopy(byte_1, 0, byte_3, 0, byte_1.length);  
        System.arraycopy(byte_2, 0, byte_3, byte_1.length, byte_2.length);  
        return byte_3;  
    }

</code></pre><h3 id="2-截取数组"><a href="#2-截取数组" class="headerlink" title="2. 截取数组"></a>2. 截取数组</h3><pre><code>    /**
     * 截取byte数组   不改变原数组
     * @param b 原数组
     * @param off 偏差值（索引）
     * @param length 长度
     * @return 截取后的数组
     */
    public byte[] subByte(byte[] b,int off,int length){
        byte[] b1 = new byte[length];
        System.arraycopy(b, off, b1, 0, length);
        return b1;
    }

</code></pre><h2 id="四、时间字符串转时间戳格式"><a href="#四、时间字符串转时间戳格式" class="headerlink" title="四、时间字符串转时间戳格式"></a>四、时间字符串转时间戳格式</h2><pre><code>public class TimeFormatTest {
    public static void main(String[] args) throws ParseException {
        String time = &quot;2019-5-23 9:24:1&quot;;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

        java.util.Date date_util = sdf.parse(time); //转换为util.date
        java.sql.Date date_sql = new java.sql.Date(date_util.getTime());//转换为sql.date
        System.out.println(date_util);
        System.out.println(date_sql);
        String date = sdf.format(date_sql);
        System.out.println(date);
        date = sdf.format(date_util);
        System.out.println(date);

    }
    }

</code></pre><h2 id="五、-netty和springboot整合"><a href="#五、-netty和springboot整合" class="headerlink" title="五、 netty和springboot整合"></a>五、 netty和springboot整合</h2><p>引入pom.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.gree.cn&lt;/groupId&gt;
    &lt;artifactId&gt;basedata&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;basedata&lt;/name&gt;
    &lt;description&gt;get base data&lt;/description&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- spring boot begin--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- springboot 和 netty 整合 socket--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
            &lt;version&gt;4.1.31.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- spring boot 和 netty整合 socket 结束--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.16.20&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
            &lt;version&gt;5.2.0&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--kafka 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--mysql 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.44&lt;/version&gt;
        &lt;/dependency&gt;


        &lt;!-- log4j--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
            &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;


</code></pre><p>其中主要引入包为：</p>
<pre><code> &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
            &lt;version&gt;4.1.31.Final&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre><h3 id="第一步创建NettyTcoServer服务端"><a href="#第一步创建NettyTcoServer服务端" class="headerlink" title="第一步创建NettyTcoServer服务端"></a>第一步创建NettyTcoServer服务端</h3><pre><code>package com.gree.cn.basedata.server;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.util.concurrent.Future;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.PreDestroy;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class NettyTcpServer {

    private static final Logger log = LoggerFactory.getLogger(NettyTcpServer.class);
    //boss事件轮询线程组
    //处理Accept连接事件的线程，这里线程数设置为1即可，netty处理链接事件默认为单线程，过度设置反而浪费cpu资源
    private EventLoopGroup boss = new NioEventLoopGroup(1);
    //worker事件轮询线程组
    //处理hadnler的工作线程，其实也就是处理IO读写 。线程数据默认为 CPU 核心数乘以2
    private EventLoopGroup worker = new NioEventLoopGroup();

    @Autowired
    ServerChannelInitializer serverChannelInitializer;

    @Value(&quot;${netty.tcp.client.port}&quot;)
    private Integer port;

    //与客户端建立连接后得到的通道对象
    private Channel channel;

    /**
     * 存储client的channel
     * key:ip，value:Channel
     */
    public static Map&lt;String, Channel&gt; map = new ConcurrentHashMap&lt;String, Channel&gt;();

    /**
     * 开启Netty tcp server服务
     *
     * @return
     */
    public ChannelFuture start() {
        //启动类
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        serverBootstrap.group(boss, worker)//组配置，初始化ServerBootstrap的线程组
                .channel(NioServerSocketChannel.class)///构造channel通道工厂//bossGroup的通道，只是负责连接
                .childHandler(serverChannelInitializer)//设置通道处理者ChannelHandler////workerGroup的处理器
                .option(ChannelOption.SO_BACKLOG, 1024)//socket参数，当服务器请求处理程全满时，用于临时存放已完成三次握手请求的队列的最大长度。如果未设置或所设置的值小于1，Java将使用默认值50。
                .childOption(ChannelOption.SO_KEEPALIVE, true);//启用心跳保活机制，tcp，默认2小时发一次心跳
        //Future：异步任务的生命周期，可用来获取任务结果
        ChannelFuture channelFuture1 = serverBootstrap.bind(port).syncUninterruptibly();//绑定端口，开启监听，同步等待
        if (channelFuture1 != null &amp;&amp; channelFuture1.isSuccess()) {
            channel = channelFuture1.channel();//获取通道
            log.info(&quot;Netty tcp server start success, port = {}&quot;, port);
        } else {
            log.error(&quot;Netty tcp server start fail&quot;);
        }
        return channelFuture1;
    }

    /**
     * 停止Netty tcp server服务
     */
    @PreDestroy
    public void destroy() {
        if (channel != null) {
            channel.close();
        }
        try {
            Future&lt;?&gt; future = worker.shutdownGracefully().await();
            if (!future.isSuccess()) {
                log.error(&quot;netty tcp workerGroup shutdown fail, {}&quot;, future.cause());
            }
            Future&lt;?&gt; future1 = boss.shutdownGracefully().await();
            if (!future1.isSuccess()) {
                log.error(&quot;netty tcp bossGroup shutdown fail, {}&quot;, future1.cause());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(&quot;Netty tcp server shutdown success&quot;);
    }

}

</code></pre><h3 id="第二步编写通道初始化流程"><a href="#第二步编写通道初始化流程" class="headerlink" title="第二步编写通道初始化流程"></a>第二步编写通道初始化流程</h3><pre><code>package com.gree.cn.basedata.server;

import com.gree.cn.basedata.utils.decodeutil.MyDecoder;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
import io.netty.handler.timeout.IdleStateHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;


@Component
public class ServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; {

    @Autowired
    ServerChannelHandler serverChannelHandler;

    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception {
        ChannelPipeline pipeline = socketChannel.pipeline();
        //IdleStateHandler心跳机制,如果超时触发Handle中userEventTrigger()方法
        pipeline.addLast(&quot;idleStateHandler&quot;,
                new IdleStateHandler(10, 0, 0, TimeUnit.MINUTES));
        //自定义编码器
        byte[] delimiterByte = new byte[2];
        delimiterByte[0] = 0x02;
        delimiterByte[1] = 0x14;
        ByteBuf delimiterCode = Unpooled.copiedBuffer(delimiterByte);
        pipeline.addLast(new DelimiterBasedFrameDecoder(64,delimiterCode));
        pipeline.addLast(&quot;decoder&quot;,new MyDecoder());


        //字符串编解码器
      pipeline.addLast(
               new StringDecoder(),
               new StringEncoder());
        //自定义Handler
        pipeline.addLast(&quot;serverChannelHandler&quot;, serverChannelHandler);
    }
}

</code></pre><h3 id="第三步自定义处理数据，并存入kafka"><a href="#第三步自定义处理数据，并存入kafka" class="headerlink" title="第三步自定义处理数据，并存入kafka"></a>第三步自定义处理数据，并存入kafka</h3><pre><code>package com.gree.cn.basedata.server;

import com.gree.cn.basedata.kafka_netty.KafkaProducerSingleton;
import com.gree.cn.basedata.utils.DateUtils;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.timeout.IdleState;
import io.netty.handler.timeout.IdleStateEvent;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.InputStream;
import java.util.Properties;

@Component
@ChannelHandler.Sharable
@Slf4j
public class ServerChannelHandler extends SimpleChannelInboundHandler&lt;Object&gt; {
    /**
     * @param ctx 通道
     * @param msg 消息
     * @throws Exception 异常消息
     */
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {

        //kafka 生产者配置
        Properties properties = new Properties();
        //加载配置文件
        InputStream is = ServerChannelHandler.class.getResourceAsStream(&quot;/producer.properties&quot;);
        properties.load(is);
        String substring = msg.toString().substring(8, 10);

        // 返回时间戳
        if (substring.equals(&quot;77&quot;)) {
            short yeardate = Short.parseShort(DateUtils.getTimeNow().substring(0, 4));
            int monthdate = Integer.parseInt(DateUtils.getTimeNow().substring(4, 6));
            int daydate = Integer.parseInt(DateUtils.getTimeNow().substring(6, 8));
            int hoursdate = Integer.parseInt(DateUtils.getTimeNow().substring(8, 10));
            int mindate = Integer.parseInt(DateUtils.getTimeNow().substring(10, 12));
            int seconddate = Integer.parseInt(DateUtils.getTimeNow().substring(12, 14));

            byte[] test = new byte[13];
            test[0] = 0x02;
            test[1] = 0x14;
            test[2] = 0x01;
            test[3] = 0x09;
            test[4] = 0x77;
            test[5] = (byte) (0x00FF &amp; yeardate);
            test[6] = (byte) (0x00FF &amp; (yeardate &gt;&gt; 8));
            test[7] = ((byte) monthdate);
            test[8] = ((byte) daydate);
            test[9] = ((byte) hoursdate);
            test[10] = ((byte) mindate);
            test[11] = ((byte) seconddate);

            //生成异或校验码
            byte temp = test[3];
            for (int i = 4; i &lt; test.length; i++) {
                temp ^= test[i];
            }
            test[12] = temp;
            ByteBuf out = Unpooled.buffer();
           // ByteOrder order;
           // order = ByteOrder.LITTLE_ENDIAN;
            //out.order(order);
            out.writeBytes(test);
            ctx.channel().writeAndFlush(out);
        }
        //然后将传入的数据全部写入到kafka内，并加上接收时间
       // VoteProduceSendmsg voteProduceSendmsg = new VoteProduceSendmsg();
        // voteProduceSendmsg.sendMsg(msg+DateUtils.getFormatTimeNow(),properties);
 //      ExecutorService executorService = Executors.newFixedThreadPool(2);
//        executorService.submit(new HandlerProducer(msg));
        KafkaProducerSingleton kafkaProducerSingleton = KafkaProducerSingleton
                .getInstance();
        kafkaProducerSingleton.init(&quot;topic0619&quot;);
        kafkaProducerSingleton.sendKafkaMessage(msg+DateUtils.getFormatTimeNow());
        //kafkaProducerSingleton.close();
        ctx.channel().flush();

    }

    /**
     * 活跃的、有效的通道
     * 第一次连接成功后进入的方法
     *
     * @param ctx 有效的通道
     * @throws Exception 异常
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        super.channelActive(ctx);
        log.info(&quot;tcp client &quot; + getRemoteAddress(ctx) + &quot; connect success&quot;);
        //往channel map中添加channel信息
        NettyTcpServer.map.put(getIPString(ctx), ctx.channel());

    }

    /**
     * 不活动的通道
     * 连接丢失后执行的方法（client端可据此实现断线重连）
     *
     * @param ctx 不活动的通道
     * @throws Exception 异常
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        //删除Channel Map中的失效Client
        log.info(&quot;不活动通道关闭!&quot;);
        NettyTcpServer.map.remove(getIPString(ctx));
        ctx.close();

    }

    /**
     * 异常处理
     * @param ctx 通道
     * @throws Exception 异常
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        super.exceptionCaught(ctx, cause);
        //发生异常，关闭连接
        log.error(&quot;引擎 {} 的通道发生异常，即将断开连接&quot;, getRemoteAddress(ctx));
        ctx.close();//再次建议close
    }

    /**
     * 心跳机制，超时处理
     * @param ctx 通道
     * @param evt 事件
     * @throws Exception 异常
     */
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        String socketString = ctx.channel().remoteAddress().toString();
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            if (event.state() == IdleState.READER_IDLE) {
                log.info(&quot;Client: &quot; + socketString + &quot; READER_IDLE 读超时&quot;);
                ctx.disconnect();//断开
            } else if (event.state() == IdleState.WRITER_IDLE) {
                log.info(&quot;Client: &quot; + socketString + &quot; WRITER_IDLE 写超时&quot;);
                ctx.disconnect();

            } else if (event.state() == IdleState.ALL_IDLE) {
                log.info(&quot;Client: &quot; + socketString + &quot; ALL_IDLE 总超时&quot;);
                ctx.disconnect();
            }
        }
    }

    /**
     * 获取client对象：ip+port
     *
     * @param ctx 通道
     * @return 返回值
     */
    private String getRemoteAddress(ChannelHandlerContext ctx) {
        String socketString = &quot;&quot;;
        socketString = ctx.channel().remoteAddress().toString();
        return socketString;
    }

    /**
     * 获取client的ip
     * @param ctx 通道
     * @return 返回值
     */
    private String getIPString(ChannelHandlerContext ctx) {
        String ipString = &quot;&quot;;
        String socketString = ctx.channel().remoteAddress().toString();
        int colonAt = socketString.indexOf(&quot;:&quot;);
        ipString = socketString.substring(1, colonAt);
        return ipString;
    }

}

</code></pre><pre><code>创建necat 
.\nc.exe -l  -p 9000

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/22/netty-遇到的坑/" data-id="ck3o5xx7f002f8wujvykjgcap"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/netty/">netty</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-MySQL-语句记录" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/16/MySQL-语句记录/">MySQL 语句记录</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/16/MySQL-语句记录/" class="article-date">
  <time datetime="2019-05-16T06:36:17.000Z" itemprop="datePublished">2019-05-16</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/sql/">sql</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>sqlserver 统计具有重复字段的记录：</p>
<pre><code>SELECT product_id, COUNT(*) AS sumCount FROM dat_bill_201811 GROUP BY product_id HAVING sumCount &gt; 1;

</code></pre><p>统计出a表有的b表没有的数据：</p>
<pre><code>select a.* FROM A a left outer join B b on a.qq = b.qq
WHERE b.qq is null;


</code></pre><p>mysql 统计具有重复字段的记录(hive也可以)：</p>
<pre><code>select username,count(*) as count from hk_test group by username having count&gt;1;

</code></pre><h3 id="MySQL8-x-连接"><a href="#MySQL8-x-连接" class="headerlink" title="MySQL8.x 连接"></a>MySQL8.x 连接</h3><blockquote>
<p>jdbc.driverClass=com.mysql.cj.jdbc.Driver<br>jdbc.connectionURL=jdbc:mysql://127.0.0.1:3306/spring-cloud-itoken-service-admin?serverTimezone=GMT&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false<br>jdbc.username=root<br>jdbc.password=123456</p>
</blockquote>
<p>主要关注的驱动不同，新加了cj这个东东，然后可能时区问题新加serverTimezone=GMT</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/16/MySQL-语句记录/" data-id="ck3o5xx6e000u8wuj28utk12l"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-spring-cloud" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/12/spring-cloud/">spring cloud</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/12/spring-cloud/" class="article-date">
  <time datetime="2019-05-12T01:57:13.000Z" itemprop="datePublished">2019-05-12</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a> / <a class="article-category-link" href="/categories/spring/spring-cloud/">spring cloud </a> / <a class="article-category-link" href="/categories/spring/spring-cloud/微服务/">微服务</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>::: hljs-center</p>
<p>spring cloud 常见错误以及解决办法<br>:::</p>
<h3 id="问题-1：找不到主类或加载不到主类"><a href="#问题-1：找不到主类或加载不到主类" class="headerlink" title="问题 1：找不到主类或加载不到主类"></a>问题 1：找不到主类或加载不到主类</h3><p>解决办法：尝试 mvn clean ，mvn install</p>
<h3 id="问题2：Module-“spring-cloud-itoken”"><a href="#问题2：Module-“spring-cloud-itoken”" class="headerlink" title="问题2：Module “spring-cloud-itoken”"></a>问题2：Module “spring-cloud-itoken”</h3><p>must not contain source root “C:\Users\hadoop\IdeaProjects\spring-cloud-itoken\spring-cloud-itoken-admin\src\main\java”.<br>The root already belongs to module “spring-cloud-itoken-admin”<br>解决办法：这类问题通常是由于多模块项目，删除了root 模块的src 目录造成的</p>
<p><img src="/images/2019/05/27/a4fe2200-802e-11e9-b471-85e9a7e0c091.png" alt="image.png"></p>
<p>所有找到root模块，然后将其右侧的sources 下的多余文件找到并删除即可。</p>
<h3 id="问题3-：java程序找不到包"><a href="#问题3-：java程序找不到包" class="headerlink" title="问题3 ：java程序找不到包"></a>问题3 ：java程序找不到包</h3><p>解决办法：<img src="/images/2019/05/27/0e0fb740-802f-11e9-b471-85e9a7e0c091.png" alt="image.png"></p>
<p>重新设置module sdk 的路径一般能够解决。</p>
<h3 id="问题4-：org-springframework-beans-factory-UnsatisfiedDependencyException-Error-creating-bean-with-name-‘com-sfz-spring-cloud-itoken-service-admin-test-admin-AdminServiceTest’-Unsatisfied-dependency-expressed-through-field-‘adminService’-nested-exception-is-org-springframework-beans-factory-NoSuchBeanDefinitionException-No-qualifying-bean-of-type-‘com-sfz-spring-cloud-itoken-service-admin-service-AdminService’-available-expected-at-least-1-bean-which-qualifies-as-autowire-candidate-Dependency-annotations-org-springframework-beans-factory-annotation-Autowired-required-true"><a href="#问题4-：org-springframework-beans-factory-UnsatisfiedDependencyException-Error-creating-bean-with-name-‘com-sfz-spring-cloud-itoken-service-admin-test-admin-AdminServiceTest’-Unsatisfied-dependency-expressed-through-field-‘adminService’-nested-exception-is-org-springframework-beans-factory-NoSuchBeanDefinitionException-No-qualifying-bean-of-type-‘com-sfz-spring-cloud-itoken-service-admin-service-AdminService’-available-expected-at-least-1-bean-which-qualifies-as-autowire-candidate-Dependency-annotations-org-springframework-beans-factory-annotation-Autowired-required-true" class="headerlink" title="问题4 ：org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘com.sfz.spring.cloud.itoken.service.admin.test.admin.AdminServiceTest’: Unsatisfied dependency expressed through field ‘adminService’; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘com.sfz.spring.cloud.itoken.service.admin.service.AdminService’ available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}"></a>问题4 ：org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘com.sfz.spring.cloud.itoken.service.admin.test.admin.AdminServiceTest’: Unsatisfied dependency expressed through field ‘adminService’; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘com.sfz.spring.cloud.itoken.service.admin.service.AdminService’ available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: <a href="mailto:{@org.springframework.beans.factory.annotation.Autowired" target="_blank" rel="noopener">{@org.springframework.beans.factory.annotation.Autowired</a>(required=true)}</h3><p> 解决办法啊： 在 serviceImpl 加上注解 @Service</p>
<h3 id="问题5-：-java-lang-IllegalStateException-Failed-to-load-ApplicationContext"><a href="#问题5-：-java-lang-IllegalStateException-Failed-to-load-ApplicationContext" class="headerlink" title="问题5 ： java.lang.IllegalStateException: Failed to load ApplicationContext"></a>问题5 ： java.lang.IllegalStateException: Failed to load ApplicationContext</h3><p> 解决办法 ：未启动ConfigApplication,验证方法：打开<a href="http://127.0.0.1:8888/spring-cloud-itoken-service-admin/prod" target="_blank" rel="noopener">http://127.0.0.1:8888/spring-cloud-itoken-service-admin/prod</a></p>
<h3 id="问题6-：Caused-by-java-net-ConnectException-Connection-refused-connect"><a href="#问题6-：Caused-by-java-net-ConnectException-Connection-refused-connect" class="headerlink" title="问题6 ：Caused by: java.net.ConnectException: Connection refused: connect"></a>问题6 ：Caused by: java.net.ConnectException: Connection refused: connect</h3><p>解决办法： 未加载注解 @ActiveProfiles(value = “prod”)</p>
<h3 id="问题7-：Failed-to-execute-goal-on-project-spring-cloud-itoken-web-admin-Could-not-resolve-dependencies-for-project-com-sfz-spring-cloud-itoken-web-admin-jar-1-0-0-SNAPSHOT-Failure-to-find-com-sfz-spring-cloud-itoken-common-web-jar-1-0-0-SNAPSHOT-in-https-oss-sonatype-org-content-repositories-snapshots-was-cached-in-the-local-repository-resolution-will-not-be-reattempted-until-the-update-interval-of-sonatype-repos-s-has-elapsed-or-updates-are-forced-gt-Help-1"><a href="#问题7-：Failed-to-execute-goal-on-project-spring-cloud-itoken-web-admin-Could-not-resolve-dependencies-for-project-com-sfz-spring-cloud-itoken-web-admin-jar-1-0-0-SNAPSHOT-Failure-to-find-com-sfz-spring-cloud-itoken-common-web-jar-1-0-0-SNAPSHOT-in-https-oss-sonatype-org-content-repositories-snapshots-was-cached-in-the-local-repository-resolution-will-not-be-reattempted-until-the-update-interval-of-sonatype-repos-s-has-elapsed-or-updates-are-forced-gt-Help-1" class="headerlink" title="问题7 ：Failed to execute goal on project spring-cloud-itoken-web-admin: Could not resolve dependencies for project com.sfz:spring-cloud-itoken-web-admin:jar:1.0.0-SNAPSHOT: Failure to find com.sfz:spring-cloud-itoken-common-web:jar:1.0.0-SNAPSHOT in https://oss.sonatype.org/content/repositories/snapshots was cached in the local repository, resolution will not be reattempted until the update interval of sonatype-repos-s has elapsed or updates are forced -&gt; [Help 1]"></a>问题7 ：Failed to execute goal on project spring-cloud-itoken-web-admin: Could not resolve dependencies for project com.sfz:spring-cloud-itoken-web-admin:jar:1.0.0-SNAPSHOT: Failure to find com.sfz:spring-cloud-itoken-common-web:jar:1.0.0-SNAPSHOT in <a href="https://oss.sonatype.org/content/repositories/snapshots" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots</a> was cached in the local repository, resolution will not be reattempted until the update interval of sonatype-repos-s has elapsed or updates are forced -&gt; [Help 1]</h3><p>解决办法： 在父项目下有的子项目在首次运行clean 和install前应该先运行父项目的clean和install</p>
<h3 id="问题8：Caused-by-java-lang-ClassNotFoundException-com-netflix-hystrix-contrib-javanica-aop-aspectj-HystrixCommandAspect"><a href="#问题8：Caused-by-java-lang-ClassNotFoundException-com-netflix-hystrix-contrib-javanica-aop-aspectj-HystrixCommandAspect" class="headerlink" title="问题8：Caused by: java.lang.ClassNotFoundException: com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect"></a>问题8：Caused by: java.lang.ClassNotFoundException: com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect</h3><p>解决办法：新增依赖</p>
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/12/spring-cloud/" data-id="ck3o5xx8a003i8wujt9ziuq8j"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/">spring cloud</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-Linux-磁盘挂载" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/07/Linux-磁盘挂载/">Linux 磁盘挂载</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/07/Linux-磁盘挂载/" class="article-date">
  <time datetime="2019-05-07T08:57:14.000Z" itemprop="datePublished">2019-05-07</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>在实际的生产应用中，经常需要对服务器的磁盘进行挂载。故总结下相关的操作，以备不时之需。<br>1、fdisk -l 查看磁盘信息<br><img src="/images/2019/05/07/0fc79190-70a6-11e9-b77c-4dd7e82ca243.png" alt="image.png"></p>
<p>2、fdisk /dev/vda 分区初始化<br><img src="/images/2019/05/07/b8555440-70a7-11e9-a040-a559da770dd7.png" alt="image.png"></p>
<p>各个参数解析：</p>
<ol>
<li>m 显示所有命令列表</li>
<li>p 显示硬盘分割情形，打印分区表</li>
<li>a 设定硬盘启动区</li>
<li>n 设定新的硬盘分割区<br>4.1 e  硬盘为延伸分割区<br>4.2 p  硬盘为主要分割区<br>5.d 删除硬盘分割区属性<br>6.q 结束不存在硬盘分割区属性<br>7.w 结束并写入硬盘分割区属性<br>umount /opt 卸载挂载<br>mke2fs  -t ext4  /dev/vda1 # ext4创建文件系统<br>df -h :查看当前硬盘使用情况</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/07/Linux-磁盘挂载/" data-id="ck3o5xx6a000p8wujwseau5yl"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-kafka相关的常规操作" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/kafka相关的常规操作/">kafka相关的常规操作</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/kafka相关的常规操作/" class="article-date">
  <time datetime="2019-04-30T07:10:31.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">kafka</a> / <a class="article-category-link" href="/categories/kafka/消息队列/">消息队列</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h3 id="1、启动服务器"><a href="#1、启动服务器" class="headerlink" title="1、启动服务器"></a>1、启动服务器</h3><pre><code>cd /usr/local/kafka/kafka_2.11-2.2.0

bin/zookeeper-server-start.sh  -daemon config/zookeeper.properties

bin/kafka-server-start.sh  -daemon config/server.properties

</code></pre><h3 id="2、创建主题"><a href="#2、创建主题" class="headerlink" title="2、创建主题"></a>2、创建主题</h3><p>创建一个名为“test”的主题，它只包含一个分区，只有一个副本：</p>
<pre><code>bin/kafka-topics.sh --create --bootstrap-server lyxbdw-01:9092 --replication-factor 1 --partitions 1 --topic test

</code></pre><p>查看主题：</p>
<pre><code>bin/kafka-topics.sh --list --bootstrap-server lyxbdw-01:9092 test

</code></pre><h3 id="3、生产者发送消息"><a href="#3、生产者发送消息" class="headerlink" title="3、生产者发送消息"></a>3、生产者发送消息</h3><pre><code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test

</code></pre><h3 id="4-kafka生产者创建消息"><a href="#4-kafka生产者创建消息" class="headerlink" title="4.kafka生产者创建消息"></a>4.kafka生产者创建消息</h3><pre><code>package com.gree.cn.basedata.kafka_netty;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;


public final class KafkaProducerSingleton {

    private static KafkaProducer&lt;Integer, Object&gt; kafkaProducer;

    private String topic;

    private KafkaProducerSingleton() {

    }


    /**
     * 静态内部类
     *
     * @author tanjie
     *
     */
    private static class LazyHandler {

        private static final KafkaProducerSingleton instance = new KafkaProducerSingleton();
    }

    /**
     * 单例模式,kafkaProducer是线程安全的,可以多线程共享一个实例
     *
     * @return
     */
    public static final KafkaProducerSingleton getInstance() {
        return LazyHandler.instance;
    }

    /**
     * kafka生产者进行初始化
     *
     * @return KafkaProducer
     */
    public void init(String topic) {
        this.topic = topic;
        if (null == kafkaProducer) {
            Properties props = new Properties();
            InputStream inStream = null;
            try {
                inStream = this.getClass().getClassLoader()
                        .getResourceAsStream(&quot;producer.properties&quot;);
                props.load(inStream);
                kafkaProducer = new KafkaProducer&lt;Integer, Object&gt;(props);
            } catch (IOException e) {
               e.printStackTrace();
            } finally {
                if (null != inStream) {
                    try {
                        inStream.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    /**
     * 通过kafkaProducer发送消息
     *  具体消息值
     */
    public void sendKafkaMessage( String message) {
        /**
         * 1、如果指定了某个分区,会只讲消息发到这个分区上 2、如果同时指定了某个分区和key,则也会将消息发送到指定分区上,key不起作用
         * 3、如果没有指定分区和key,那么将会随机发送到topic的分区中 4、如果指定了key,那么将会以hash&lt;key&gt;的方式发送到分区中
         */
        ProducerRecord&lt;Integer, Object&gt; record = new ProducerRecord&lt;Integer, Object&gt;(
                topic, message);
        // send方法是异步的,添加消息到缓存区等待发送,并立即返回，这使生产者通过批量发送消息来提高效率
        // kafka生产者是线程安全的,可以单实例发送消息
        kafkaProducer.send(record);
    }


    /**
     * kafka实例销毁
     */
    public void close() {
        if (null != kafkaProducer) {
            kafkaProducer.close();
        }
    }

    public String getTopic() {
        return topic;
    }

    public void setTopic(String topic) {
        this.topic = topic;
    }
}


</code></pre><p>然后调用用producer实例</p>
<pre><code> KafkaProducerSingleton kafkaProducerSingleton = KafkaProducerSingleton
                .getInstance();
        kafkaProducerSingleton.init(&quot;topic0619&quot;);
        kafkaProducerSingleton.sendKafkaMessage(msg+DateUtils.getFormatTimeNow());

</code></pre><p>注意配置producer.properties文件</p>
<blockquote>
<p>#指定节点列表<br>bootstrap.servers=10.7.20.190:9092,10.7.20.191:9092,10.7.17.9:9092</p>
</blockquote>
<p>#指定序列化处理类<br>key.serializer=org.apache.kafka.common.serialization.IntegerSerializer<br>value.serializer=org.apache.kafka.common.serialization.StringSerializer<br>acks=0</p>
<p>#buffer.memory=33554432</p>
<p>#是否压缩<br>compression.type=snappy</p>
<p>#是否重试<br>retries=0<br>batch.size=500<br>request.timeout.ms=5000</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/kafka相关的常规操作/" data-id="ck3o5xx6z001u8wujktir6mha"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消息队列/">消息队列</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-kafka-集群安装-部署" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/kafka-集群安装-部署/">kafka 集群安装 部署</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/kafka-集群安装-部署/" class="article-date">
  <time datetime="2019-04-30T03:45:07.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">kafka</a>
  </div>

      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h1 id="kafka-集群安装部署"><a href="#kafka-集群安装部署" class="headerlink" title="kafka 集群安装部署"></a>kafka 集群安装部署</h1><p>  安装kafka首先需要安装zookeeper集群，这里使用的是kafka自带的zookeeper,不推荐使用（我也不知道为啥，别人都这么说）。</p>
<h2 id="jdk-安装"><a href="#jdk-安装" class="headerlink" title="jdk 安装"></a>jdk 安装</h2><p>jdk 自己下载吧，后解压</p>
<pre><code>cd /usr/local/java
tar -zxvf jdk-8u11-linux-x64.tar.gz
</code></pre><p>配置环境变量</p>
<pre><code>vi /etc/profile
#jdk环境变量配置
 export JAVA_HOME=/usr/local/java/jdk1.8.0_11
 export JRE_HOME=${JAVA_HOME}/jre
 export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
 export PATH=${JAVA_HOME}/bin:$PATH

</code></pre><p>echo “JAVA_HOME=/usr/local/java/jdk1.8.0_11/“ &gt;&gt; /etc/environment</p>
<p>然后配置其他机器<br>scp -r -P 2122  root@lyxbdw-02:/usr/local/java /usr/local</p>
<h2 id="zookeepeer集群安装"><a href="#zookeepeer集群安装" class="headerlink" title="zookeepeer集群安装"></a>zookeepeer集群安装</h2><pre><code>cd /usr/local/kafka
tar -xzf kafka_2.12-2.2.0.tgz
cd kafka_2.12-2.2.0
</code></pre><p>配置zookeeper配置文件 zookeeper.properties</p>
<pre><code>vim config/zookeeper.properties
====================================================
dataDir=/usr/local/kafka/kafka_2.11-2.2.0/zookeeper
Time=2000  
initLimit=10  
syncLimit=5

server.1=lyxbdw-01:2888:3888  
server.2=lyxbdw-02:2888:3888  
server.3=lyxbdw-03:2888:3888
</code></pre><p>然后在/usr/local/kafka/kafka_2.11-2.2.0/zookeeper 创建myid文件编辑</p>
<pre><code>vi myid
==================
1
</code></pre><p>其他机器复制 zookeeper.properties到相应的目录，并设置不同的myid值<br>每台机器都启动</p>
<pre><code>bin/zookeeper-server-start.sh  -daemon config/zookeeper.properties

</code></pre><h2 id="kafka集群安装"><a href="#kafka集群安装" class="headerlink" title="kafka集群安装"></a>kafka集群安装</h2><p>这里主要就是配置相关的配置信息，server.properties</p>
<pre><code>vim config/server.properties
=====================================
broker.id=1
host.name=lyxbdw-02
log.dirs=/tmp/kafka-logs
zookeeper.connect=lyxbdw-01:2181,lyxbdw-02:2181,lyxbdw-03:2181
</code></pre><p>然后进入到log日志目录下，修改meta.properties文件</p>
<pre><code>vim /tmp/kafka-logs/meta.properties
======================================
broker.id=1
</code></pre><p>其他机器类似，最后启动kafak 服务</p>
<pre><code>bin/kafka-server-start.sh  -daemon config/server.properties
</code></pre><p>到此，使用kafka自带的zookeeper安装就完成了。</p>
<blockquote>
<p>当然，在实际的生成应用中，需要注意以下事项：<br>1、数据目录需要放在磁盘的目录下<br>2、进程启动最好是在后台启动 -daemon 命令可以实现。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/kafka-集群安装-部署/" data-id="ck3o5xx6z001s8wujyolvmdh0"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
  </article>
  

  
    <nav class="page-nav">
      
      <a class="extend prev" rel="prev" href="/page/2/">Prev page</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next page</a>
    </nav>
  
</section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 上善若水博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

  <aside class="sidebar">
    
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="上善若水博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>